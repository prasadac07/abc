package com.barclays.iportalmonitoring.service.impl;

import com.barclays.iportalmonitoring.annotation.ClusterIdentifier;
import com.barclays.iportalmonitoring.annotation.UseOpenShiftClient;
import com.barclays.iportalmonitoring.model.HealthCheckResponse;
import com.barclays.iportalmonitoring.service.HealthCheckService;
import com.barclays.iportalmonitoring.service.OpenShiftService;
import io.fabric8.kubernetes.api.model.Container;
import io.fabric8.kubernetes.api.model.Pod;
import io.fabric8.kubernetes.api.model.Probe;
import io.fabric8.kubernetes.api.model.Service;
import io.fabric8.kubernetes.api.model.apps.Deployment;
import io.fabric8.openshift.api.model.Route;
import io.fabric8.openshift.client.OpenShiftClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors;

@Service
public class HealthCheckServiceImpl implements HealthCheckService {

    private final OpenShiftService openShiftService;

    @Autowired
    public HealthCheckServiceImpl(OpenShiftService openShiftService) {
        this.openShiftService = openShiftService;
    }

    @Override
    @UseOpenShiftClient
    public List<HealthCheckResponse> checkDeploymentHealth(@ClusterIdentifier String cluster, String project) {
        OpenShiftClient client = openShiftService.getActiveClient();

        if (client == null) {
            throw new RuntimeException("Openshift client not available for cluster: " + cluster);
        }

        List<Deployment> deployments = client.apps().deployments().inNamespace(project).list().getItems();
        List<Service> services = client.services().inNamespace(project).list().getItems();
        List<Route> routes = client.routes().inNamespace(project).list().getItems();

        Map<String, String> serviceToRouteMap = routes.stream().collect(Collectors.toMap(
                route -> route.getSpec().getTo().getName(),
                route -> {
                    String scheme = route.getSpec().getTls() != null ? "https" : "http";
                    return scheme + "://" + route.getSpec().getHost();
                },
                (url1, url2) -> url1
        ));

        List<HealthCheckResponse> healthCheckResults = new ArrayList<>();
        ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
        List<Future<HealthCheckResponse>> futures = new ArrayList<>();

        for (Deployment deployment : deployments) {
            Map<String, String> podLabels = deployment.getSpec().getTemplate().getMetadata().getLabels();
            if (podLabels == null || podLabels.isEmpty()) continue;

            Optional<Service> matchingServiceOpt = services.stream()
                    .filter(service -> isSelectorMatch(podLabels, service.getSpec().getSelector()))
                    .findFirst();

            String serviceName = matchingServiceOpt.map(s -> s.getMetadata().getName()).orElse("N/A");
            String routeUrl = matchingServiceOpt.map(s -> serviceToRouteMap.get(s.getMetadata().getName())).orElse("N/A");
            List<Pod> deploymentPods = client.pods().inNamespace(project).withLabels(podLabels).list().getItems();

            if (deploymentPods.isEmpty()) {
                healthCheckResults.add(createNoPodsResponse(deployment, serviceName, routeUrl));
                continue;
            }

            for (Pod pod : deploymentPods) {
                for (Container container : pod.getSpec().getContainers()) {
                    futures.add(executor.submit(() -> processSinglePod(deployment, pod, container, routeUrl, serviceName)));
                }
            }
        }

        for (Future<HealthCheckResponse> future : futures) {
            try {
                healthCheckResults.add(future.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        }

        executor.shutdown();
        return healthCheckResults;
    }

    private HealthCheckResponse processSinglePod(Deployment deployment, Pod pod, Container container, String routeUrl, String serviceName) {
        HealthCheckResponse response = new HealthCheckResponse();
        String podStatus = pod.getStatus().getPhase();

        response.setDeployment(deployment.getMetadata().getName());
        response.setPodName(pod.getMetadata().getName());
        response.setContainer(container.getName());
        response.setService(serviceName);
        response.setRoute(routeUrl);

        String livenessPath = getProbePath(container.getLivenessProbe());
        String readinessPath = getProbePath(container.getReadinessProbe());

        response.setLivenessPath(livenessPath);
        response.setReadinessPath(readinessPath);

        if ("Running".equalsIgnoreCase(podStatus) && !"N/A".equals(routeUrl)) {
            response.setLivenessStatus(getHttpStatus(routeUrl, livenessPath));
            response.setReadinessStatus(getHttpStatus(routeUrl, readinessPath));
        } else {
            response.setLivenessStatus("Pod Status: " + podStatus);
            response.setReadinessStatus("Pod Status: " + podStatus);
        }

        return response;
    }

    private HealthCheckResponse createNoPodsResponse(Deployment deployment, String serviceName, String routeUrl) {
        HealthCheckResponse response = new HealthCheckResponse();
        response.setDeployment(deployment.getMetadata().getName());
        response.setPodName("No Pod Found");
        response.setContainer(deployment.getSpec().getTemplate().getSpec().getContainers().get(0).getName());
        response.setService(serviceName);
        response.setRoute(routeUrl);
        response.setLivenessStatus("Scaled to Zero");
        response.setReadinessStatus("Scaled to Zero");
        return response;
    }

    private boolean isSelectorMatch(Map<String, String> podLabels, Map<String, String> serviceSelector) {
        if (serviceSelector == null || serviceSelector.isEmpty()) return false;
        return podLabels.entrySet().containsAll(serviceSelector.entrySet());
    }

    private String getProbePath(Probe probe) {
        return Optional.ofNullable(probe)
                .map(p -> p.getHttpGet() != null ? p.getHttpGet().getPath() : null)
                .orElse(null);
    }

    private String getHttpStatus(String baseUrl, String path) {
        if (path == null || "N/A".equals(path)) return "Probe Not Defined";

        try {
            String fullUrl = baseUrl + (path.startsWith("/") ? path : "/" + path);
            HttpClient client = HttpClient.newHttpClient();
            HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create(fullUrl))
                    .timeout(Duration.ofSeconds(10))
                    .GET()
                    .build();
            HttpResponse<Void> response = client.send(request, HttpResponse.BodyHandlers.discarding());
            return String.valueOf(response.statusCode());
        } catch (Exception e) {
            return e.getClass().getSimpleName() + ": " + e.getMessage();
        }
    }
}
